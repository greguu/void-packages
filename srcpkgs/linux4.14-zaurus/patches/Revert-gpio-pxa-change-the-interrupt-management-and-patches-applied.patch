From 24930eabf92802990dc4edfbb7213c8b5129cd3e Mon Sep 17 00:00:00 2001
From: greguu <greguu@null.net>
Date: Tue, 20 Feb 2018 19:53:35 +1300
Subject: [PATCH] Revert gpio: pxa: change the interrupt management and patches
 applied after

---
 drivers/gpio/gpio-pxa.c | 209 +++++++++++++++++++-----------------------------
 1 file changed, 82 insertions(+), 127 deletions(-)

diff --git a/drivers/gpio/gpio-pxa.c b/drivers/gpio/gpio-pxa.c
index 60298997..69916c65 100644
--- a/drivers/gpio/gpio-pxa.c
+++ b/drivers/gpio/gpio-pxa.c
@@ -24,7 +24,6 @@
 #include <linux/io.h>
 #include <linux/of.h>
 #include <linux/of_device.h>
-#include <linux/pinctrl/consumer.h>
 #include <linux/platform_device.h>
 #include <linux/syscore_ops.h>
 #include <linux/slab.h>
@@ -65,6 +64,11 @@
 int pxa_last_gpio;
 static int irq_base;
 
+#ifdef CONFIG_OF
+static struct irq_domain *domain;
+static struct device_node *pxa_gpio_of_node;
+#endif
+
 struct pxa_gpio_bank {
 	void __iomem	*regbase;
 	unsigned long	irq_mask;
@@ -83,7 +87,6 @@ struct pxa_gpio_chip {
 	struct device *dev;
 	struct gpio_chip chip;
 	struct pxa_gpio_bank *banks;
-	struct irq_domain *irqdomain;
 
 	int irq0;
 	int irq1;
@@ -155,15 +158,14 @@ static struct pxa_gpio_id pxa1928_id = {
 
 static inline struct pxa_gpio_chip *chip_to_pxachip(struct gpio_chip *c)
 {
-	struct pxa_gpio_chip *pxa_chip = gpiochip_get_data(c);
+	struct pxa_gpio_chip *pxa_chip =
+		container_of(c, struct pxa_gpio_chip, chip);
 
 	return pxa_chip;
 }
-
 static inline void __iomem *gpio_bank_base(struct gpio_chip *c, int gpio)
 {
-	struct pxa_gpio_chip *p = gpiochip_get_data(c);
-	struct pxa_gpio_bank *bank = p->banks + (gpio / 32);
+	struct pxa_gpio_bank *bank = chip_to_pxachip(c)->banks + (gpio / 32);
 
 	return bank->regbase;
 }
@@ -229,23 +231,14 @@ static inline int __gpio_is_occupied(struct pxa_gpio_chip *pchip, unsigned gpio)
 	return ret;
 }
 
-int pxa_irq_to_gpio(int irq)
+static int pxa_gpio_to_irq(struct gpio_chip *chip, unsigned offset)
 {
-	struct pxa_gpio_chip *pchip = pxa_gpio_chip;
-	int irq_gpio0;
-
-	irq_gpio0 = irq_find_mapping(pchip->irqdomain, 0);
-	if (irq_gpio0 > 0)
-		return irq - irq_gpio0;
-
-	return irq_gpio0;
+	return offset + irq_base;
 }
 
-static int pxa_gpio_to_irq(struct gpio_chip *chip, unsigned offset)
+int pxa_irq_to_gpio(int irq)
 {
-	struct pxa_gpio_chip *pchip = chip_to_pxachip(chip);
-
-	return irq_find_mapping(pchip->irqdomain, offset);
+	return irq - irq_base;
 }
 
 static int pxa_gpio_direction_input(struct gpio_chip *chip, unsigned offset)
@@ -253,11 +246,6 @@ static int pxa_gpio_direction_input(struct gpio_chip *chip, unsigned offset)
 	void __iomem *base = gpio_bank_base(chip, offset);
 	uint32_t value, mask = GPIO_bit(offset);
 	unsigned long flags;
-	int ret;
-
-	ret = pinctrl_gpio_direction_input(chip->base + offset);
-	if (!ret)
-		return 0;
 
 	spin_lock_irqsave(&gpio_lock, flags);
 
@@ -278,14 +266,9 @@ static int pxa_gpio_direction_output(struct gpio_chip *chip,
 	void __iomem *base = gpio_bank_base(chip, offset);
 	uint32_t tmp, mask = GPIO_bit(offset);
 	unsigned long flags;
-	int ret;
 
 	writel_relaxed(mask, base + (value ? GPSR_OFFSET : GPCR_OFFSET));
 
-	ret = pinctrl_gpio_direction_output(chip->base + offset);
-	if (ret)
-		return ret;
-
 	spin_lock_irqsave(&gpio_lock, flags);
 
 	tmp = readl_relaxed(base + GPDR_OFFSET);
@@ -330,18 +313,8 @@ static int pxa_gpio_of_xlate(struct gpio_chip *gc,
 }
 #endif
 
-static int pxa_gpio_request(struct gpio_chip *chip, unsigned int offset)
-{
-	return pinctrl_request_gpio(chip->base + offset);
-}
-
-static void pxa_gpio_free(struct gpio_chip *chip, unsigned int offset)
-{
-	pinctrl_free_gpio(chip->base + offset);
-}
-
 static int pxa_init_gpio_chip(struct pxa_gpio_chip *pchip, int ngpio,
-			      struct device_node *np, void __iomem *regbase)
+			      void __iomem *regbase)
 {
 	int i, gpio, nbanks = DIV_ROUND_UP(ngpio, 32);
 	struct pxa_gpio_bank *bank;
@@ -358,10 +331,8 @@ static int pxa_init_gpio_chip(struct pxa_gpio_chip *pchip, int ngpio,
 	pchip->chip.set = pxa_gpio_set;
 	pchip->chip.to_irq = pxa_gpio_to_irq;
 	pchip->chip.ngpio = ngpio;
-	pchip->chip.request = pxa_gpio_request;
-	pchip->chip.free = pxa_gpio_free;
 #ifdef CONFIG_OF_GPIO
-	pchip->chip.of_node = np;
+	pchip->chip.of_node = pxa_gpio_of_node;
 	pchip->chip.of_xlate = pxa_gpio_of_xlate;
 	pchip->chip.of_gpio_n_cells = 2;
 #endif
@@ -371,7 +342,7 @@ static int pxa_init_gpio_chip(struct pxa_gpio_chip *pchip, int ngpio,
 		bank->regbase = regbase + BANK_OFF(i);
 	}
 
-	return gpiochip_add_data(&pchip->chip, pchip);
+	return gpiochip_add(&pchip->chip);
 }
 
 /* Update only those GRERx and GFERx edge detection register bits if those
@@ -391,8 +362,8 @@ static inline void update_edge_detect(struct pxa_gpio_bank *c)
 
 static int pxa_gpio_irq_type(struct irq_data *d, unsigned int type)
 {
-	struct pxa_gpio_chip *pchip = irq_data_get_irq_chip_data(d);
-	unsigned int gpio = irqd_to_hwirq(d);
+	struct pxa_gpio_chip *pchip = pxa_gpio_chip;
+	int gpio = pxa_irq_to_gpio(d->irq);
 	struct pxa_gpio_bank *c = gpio_to_pxabank(&pchip->chip, gpio);
 	unsigned long gpdr, mask = GPIO_bit(gpio);
 
@@ -434,13 +405,16 @@ static int pxa_gpio_irq_type(struct irq_data *d, unsigned int type)
 	return 0;
 }
 
-static irqreturn_t pxa_gpio_demux_handler(int in_irq, void *d)
+static void pxa_gpio_demux_handler(struct irq_desc *desc)
 {
 	int loop, gpio, n, handled = 0;
 	unsigned long gedr;
-	struct pxa_gpio_chip *pchip = d;
+	struct irq_chip *chip = irq_desc_get_chip(desc);
+	struct pxa_gpio_chip *pchip = pxa_gpio_chip;
 	struct pxa_gpio_bank *c;
 
+	chained_irq_enter(chip, desc);
+
 	do {
 		loop = 0;
 		for_each_gpio_bank(gpio, c, pchip) {
@@ -451,36 +425,18 @@ static irqreturn_t pxa_gpio_demux_handler(int in_irq, void *d)
 			for_each_set_bit(n, &gedr, BITS_PER_LONG) {
 				loop = 1;
 
-				generic_handle_irq(
-					irq_find_mapping(pchip->irqdomain,
-							 gpio + n));
+				generic_handle_irq(gpio_to_irq(gpio + n));
 			}
 		}
-		handled += loop;
 	} while (loop);
 
-	return handled ? IRQ_HANDLED : IRQ_NONE;
-}
-
-static irqreturn_t pxa_gpio_direct_handler(int in_irq, void *d)
-{
-	struct pxa_gpio_chip *pchip = d;
-
-	if (in_irq == pchip->irq0) {
-		generic_handle_irq(irq_find_mapping(pchip->irqdomain, 0));
-	} else if (in_irq == pchip->irq1) {
-		generic_handle_irq(irq_find_mapping(pchip->irqdomain, 1));
-	} else {
-		pr_err("%s() unknown irq %d\n", __func__, in_irq);
-		return IRQ_NONE;
-	}
-	return IRQ_HANDLED;
+	chained_irq_exit(chip, desc);
 }
 
 static void pxa_ack_muxed_gpio(struct irq_data *d)
 {
-	struct pxa_gpio_chip *pchip = irq_data_get_irq_chip_data(d);
-	unsigned int gpio = irqd_to_hwirq(d);
+	struct pxa_gpio_chip *pchip = pxa_gpio_chip;
+	int gpio = pxa_irq_to_gpio(d->irq);
 	void __iomem *base = gpio_bank_base(&pchip->chip, gpio);
 
 	writel_relaxed(GPIO_bit(gpio), base + GEDR_OFFSET);
@@ -488,8 +444,8 @@ static void pxa_ack_muxed_gpio(struct irq_data *d)
 
 static void pxa_mask_muxed_gpio(struct irq_data *d)
 {
-	struct pxa_gpio_chip *pchip = irq_data_get_irq_chip_data(d);
-	unsigned int gpio = irqd_to_hwirq(d);
+	struct pxa_gpio_chip *pchip = pxa_gpio_chip;
+	int gpio = pxa_irq_to_gpio(d->irq);
 	struct pxa_gpio_bank *b = gpio_to_pxabank(&pchip->chip, gpio);
 	void __iomem *base = gpio_bank_base(&pchip->chip, gpio);
 	uint32_t grer, gfer;
@@ -504,8 +460,8 @@ static void pxa_mask_muxed_gpio(struct irq_data *d)
 
 static int pxa_gpio_set_wake(struct irq_data *d, unsigned int on)
 {
-	struct pxa_gpio_chip *pchip = irq_data_get_irq_chip_data(d);
-	unsigned int gpio = irqd_to_hwirq(d);
+	int gpio = pxa_irq_to_gpio(d->irq);
+	struct pxa_gpio_chip *pchip = pxa_gpio_chip;
 
 	if (pchip->set_wake)
 		return pchip->set_wake(gpio, on);
@@ -515,8 +471,8 @@ static int pxa_gpio_set_wake(struct irq_data *d, unsigned int on)
 
 static void pxa_unmask_muxed_gpio(struct irq_data *d)
 {
-	struct pxa_gpio_chip *pchip = irq_data_get_irq_chip_data(d);
-	unsigned int gpio = irqd_to_hwirq(d);
+	struct pxa_gpio_chip *pchip = pxa_gpio_chip;
+	int gpio = pxa_irq_to_gpio(d->irq);
 	struct pxa_gpio_bank *c = gpio_to_pxabank(&pchip->chip, gpio);
 
 	c->irq_mask |= GPIO_bit(gpio);
@@ -557,12 +513,24 @@ static int pxa_gpio_nums(struct platform_device *pdev)
 	return count;
 }
 
+#ifdef CONFIG_OF
+static const struct of_device_id pxa_gpio_dt_ids[] = {
+	{ .compatible = "intel,pxa25x-gpio",	.data = &pxa25x_id, },
+	{ .compatible = "intel,pxa26x-gpio",	.data = &pxa26x_id, },
+	{ .compatible = "intel,pxa27x-gpio",	.data = &pxa27x_id, },
+	{ .compatible = "intel,pxa3xx-gpio",	.data = &pxa3xx_id, },
+	{ .compatible = "marvell,pxa93x-gpio",	.data = &pxa93x_id, },
+	{ .compatible = "marvell,mmp-gpio",	.data = &mmp_id, },
+	{ .compatible = "marvell,mmp2-gpio",	.data = &mmp2_id, },
+	{ .compatible = "marvell,pxa1928-gpio",	.data = &pxa1928_id, },
+	{}
+};
+
 static int pxa_irq_domain_map(struct irq_domain *d, unsigned int irq,
 			      irq_hw_number_t hw)
 {
 	irq_set_chip_and_handler(irq, &pxa_muxed_gpio_chip,
 				 handle_edge_irq);
-	irq_set_chip_data(irq, d->host_data);
 	irq_set_noprobe(irq);
 	return 0;
 }
@@ -572,23 +540,11 @@ const struct irq_domain_ops pxa_irq_domain_ops = {
 	.xlate	= irq_domain_xlate_twocell,
 };
 
-#ifdef CONFIG_OF
-static const struct of_device_id pxa_gpio_dt_ids[] = {
-	{ .compatible = "intel,pxa25x-gpio",	.data = &pxa25x_id, },
-	{ .compatible = "intel,pxa26x-gpio",	.data = &pxa26x_id, },
-	{ .compatible = "intel,pxa27x-gpio",	.data = &pxa27x_id, },
-	{ .compatible = "intel,pxa3xx-gpio",	.data = &pxa3xx_id, },
-	{ .compatible = "marvell,pxa93x-gpio",	.data = &pxa93x_id, },
-	{ .compatible = "marvell,mmp-gpio",	.data = &mmp_id, },
-	{ .compatible = "marvell,mmp2-gpio",	.data = &mmp2_id, },
-	{ .compatible = "marvell,pxa1928-gpio",	.data = &pxa1928_id, },
-	{}
-};
-
 static int pxa_gpio_probe_dt(struct platform_device *pdev,
 			     struct pxa_gpio_chip *pchip)
 {
 	int nr_gpios;
+	struct device_node *np = pdev->dev.of_node;
 	const struct of_device_id *of_id =
 				of_match_device(pxa_gpio_dt_ids, &pdev->dev);
 	const struct pxa_gpio_id *gpio_id;
@@ -603,12 +559,15 @@ static int pxa_gpio_probe_dt(struct platform_device *pdev,
 	nr_gpios = gpio_id->gpio_nums;
 	pxa_last_gpio = nr_gpios - 1;
 
-	irq_base = devm_irq_alloc_descs(&pdev->dev, -1, 0, nr_gpios, 0);
+	irq_base = irq_alloc_descs(-1, 0, nr_gpios, 0);
 	if (irq_base < 0) {
 		dev_err(&pdev->dev, "Failed to allocate IRQ numbers\n");
 		return irq_base;
 	}
-	return irq_base;
+	domain = irq_domain_add_legacy(np, nr_gpios, irq_base, 0,
+				       &pxa_irq_domain_ops, pchip);
+	pxa_gpio_of_node = np;
+	return 0;
 }
 #else
 #define pxa_gpio_probe_dt(pdev, pchip)		(-1)
@@ -622,7 +581,7 @@ static int pxa_gpio_probe(struct platform_device *pdev)
 	struct clk *clk;
 	struct pxa_gpio_platform_data *info;
 	void __iomem *gpio_reg_base;
-	int gpio, ret;
+	int gpio, irq, ret, use_of = 0;
 	int irq0 = 0, irq1 = 0, irq_mux, gpio_offset = 0;
 
 	pchip = devm_kzalloc(&pdev->dev, sizeof(*pchip), GFP_KERNEL);
@@ -638,29 +597,22 @@ static int pxa_gpio_probe(struct platform_device *pdev)
 		pxa_last_gpio = pxa_gpio_nums(pdev);
 		pchip->set_wake = info->gpio_set_wake;
 	} else {
-		irq_base = pxa_gpio_probe_dt(pdev, pchip);
-		if (irq_base < 0)
+		irq_base = 0;
+		use_of = 1;
+		ret = pxa_gpio_probe_dt(pdev, pchip);
+		if (ret < 0)
 			return -EINVAL;
 	}
 
 	if (!pxa_last_gpio)
 		return -EINVAL;
 
-	pchip->irqdomain = irq_domain_add_legacy(pdev->dev.of_node,
-						 pxa_last_gpio + 1, irq_base,
-						 0, &pxa_irq_domain_ops, pchip);
-	if (!pchip->irqdomain)
-		return -ENOMEM;
-
 	irq0 = platform_get_irq_byname(pdev, "gpio0");
 	irq1 = platform_get_irq_byname(pdev, "gpio1");
 	irq_mux = platform_get_irq_byname(pdev, "gpio_mux");
 	if ((irq0 > 0 && irq1 <= 0) || (irq0 <= 0 && irq1 > 0)
 		|| (irq_mux <= 0))
 		return -EINVAL;
-
-	pchip->irq0 = irq0;
-	pchip->irq1 = irq1;
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	gpio_reg_base = devm_ioremap(&pdev->dev, res->start,
 				     resource_size(res));
@@ -683,8 +635,7 @@ static int pxa_gpio_probe(struct platform_device *pdev)
 	}
 
 	/* Initialize GPIO chips */
-	ret = pxa_init_gpio_chip(pchip, pxa_last_gpio + 1, pdev->dev.of_node,
-				 gpio_reg_base);
+	ret = pxa_init_gpio_chip(pchip, pxa_last_gpio + 1, gpio_reg_base);
 	if (ret) {
 		clk_put(clk);
 		return ret;
@@ -700,31 +651,35 @@ static int pxa_gpio_probe(struct platform_device *pdev)
 			writel_relaxed(~0, c->regbase + ED_MASK_OFFSET);
 	}
 
-	if (irq0 > 0) {
-		ret = devm_request_irq(&pdev->dev,
-				       irq0, pxa_gpio_direct_handler, 0,
-				       "gpio-0", pchip);
-		if (ret)
-			dev_err(&pdev->dev, "request of gpio0 irq failed: %d\n",
-				ret);
-	}
-	if (irq1 > 0) {
-		ret = devm_request_irq(&pdev->dev,
-				       irq1, pxa_gpio_direct_handler, 0,
-				       "gpio-1", pchip);
-		if (ret)
-			dev_err(&pdev->dev, "request of gpio1 irq failed: %d\n",
-				ret);
+	if (!use_of) {
+		if (irq0 > 0) {
+			irq = gpio_to_irq(0);
+			irq_set_chip_and_handler(irq, &pxa_muxed_gpio_chip,
+						 handle_edge_irq);
+			irq_clear_status_flags(irq, IRQ_NOREQUEST | IRQ_NOPROBE);
+		}
+		if (irq1 > 0) {
+			irq = gpio_to_irq(1);
+			irq_set_chip_and_handler(irq, &pxa_muxed_gpio_chip,
+						 handle_edge_irq);
+			irq_clear_status_flags(irq, IRQ_NOREQUEST | IRQ_NOPROBE);
+		}
+
+		for (irq  = gpio_to_irq(gpio_offset);
+			irq <= gpio_to_irq(pxa_last_gpio); irq++) {
+			irq_set_chip_and_handler(irq, &pxa_muxed_gpio_chip,
+						 handle_edge_irq);
+			irq_clear_status_flags(irq, IRQ_NOREQUEST | IRQ_NOPROBE);
+		}
 	}
-	ret = devm_request_irq(&pdev->dev,
-			       irq_mux, pxa_gpio_demux_handler, 0,
-				       "gpio-mux", pchip);
-	if (ret)
-		dev_err(&pdev->dev, "request of gpio-mux irq failed: %d\n",
-				ret);
 
+	if (irq0 > 0)
+		irq_set_chained_handler(irq0, pxa_gpio_demux_handler);
+	if (irq1 > 0)
+		irq_set_chained_handler(irq1, pxa_gpio_demux_handler);
 	pxa_gpio_chip = pchip;
 
+	irq_set_chained_handler(irq_mux, pxa_gpio_demux_handler);
 	return 0;
 }
 
